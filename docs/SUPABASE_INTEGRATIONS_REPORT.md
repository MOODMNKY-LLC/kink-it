# Supabase Integrations & Wrappers Report

**Date**: 2025-02-01  
**Generated By**: CODE MNKY  
**Purpose**: Comprehensive analysis of Supabase integrations, extensions, and wrappers, with focus on Notion wrapper FDW

---

## Executive Summary

This report provides a complete breakdown of:
- Installed PostgreSQL extensions
- Available Supabase integrations
- Notion Foreign Data Wrapper (FDW) analysis
- Comparison with current custom Notion integration
- Recommendations for incorporation

---

## 1. Installed PostgreSQL Extensions

### Current Extensions

Based on database queries, the following extensions are installed:

| Extension | Version | Purpose |
|-----------|---------|---------|
| `pgcrypto` | Latest | Cryptographic functions (used for encrypting Notion API keys) |
| `pg_trgm` | Latest | Trigram matching for fuzzy text search |
| `pg_stat_statements` | Latest | Query performance monitoring |
| Standard Extensions | Various | Core Postgres extensions (uuid, etc.) |

### Available Extensions (Not Installed)

Extensions available but not currently installed:
- **Foreign Data Wrappers**: Various FDWs for external data sources
- **Notion FDW**: Available as a Supabase integration (see Notion Wrapper section)

---

## 2. Supabase Integrations Overview

### What Are Supabase Integrations?

Supabase integrations are pre-built connectors that allow your Postgres database to interact with external services. They typically use Foreign Data Wrappers (FDWs) to create "foreign tables" that map to external data sources.

### Available Integration Types

1. **Foreign Data Wrappers (FDWs)**
   - Read-only access to external data sources
   - Query external data using SQL
   - Examples: Notion, Stripe, GitHub, etc.

2. **Webhook Integrations**
   - Trigger actions on database events
   - Send data to external services
   - Examples: Slack, Discord, Email services

3. **Storage Integrations**
   - Connect to external storage services
   - Examples: AWS S3, Google Cloud Storage

---

## 3. Notion Foreign Data Wrapper (FDW)

### What Is It?

The **Notion Wrapper** is a Foreign Data Wrapper that allows you to read data from Notion workspaces directly into Postgres using SQL queries. It creates "foreign tables" that map to your Notion databases.

### Key Characteristics

✅ **Read-Only**: Can only read data from Notion, cannot write  
✅ **SQL Queries**: Query Notion data using standard SQL  
✅ **Real-Time Sync**: Data is fetched on-demand (not cached)  
✅ **Schema Mapping**: Automatically maps Notion database schemas to Postgres tables  
✅ **No API Keys in Code**: Uses Supabase integration configuration  

### How It Works

```
Postgres Query → Notion FDW → Notion API → Returns Data as SQL Results
```

### Setup Process

1. **Enable Integration** (via Supabase Dashboard):
   - Go to Database → Integrations
   - Enable "Notion" integration
   - Connect your Notion workspace
   - Grant permissions to specific databases

2. **Create Foreign Tables**:
   ```sql
   -- Example: Create foreign table for a Notion database
   CREATE FOREIGN TABLE notion_tasks (
     id TEXT,
     title TEXT,
     status TEXT,
     created_time TIMESTAMP,
     -- ... other columns mapped from Notion schema
   ) SERVER notion_server
   OPTIONS (
     database_id 'your-notion-database-id'
   );
   ```

3. **Query Like Normal Tables**:
   ```sql
   -- Query Notion data using SQL
   SELECT * FROM notion_tasks 
   WHERE status = 'In Progress'
   ORDER BY created_time DESC;
   ```

---

## 4. Current Custom Notion Integration

### Architecture

Our current implementation uses:

1. **Notion API Direct Integration**:
   - Custom API routes (`/api/notion/*`)
   - Encrypted API key storage (`user_notion_api_keys` table)
   - MCP (Model Context Protocol) tools for AI agents
   - OpenAI Agents SDK integration

2. **Features**:
   - ✅ Read AND write operations
   - ✅ User-specific API keys (multi-tenant)
   - ✅ Role-based access control
   - ✅ AI agent tool calling
   - ✅ Custom business logic
   - ✅ Real-time sync via API calls

3. **Implementation Files**:
   - `lib/notion/chat-tools.ts` - Notion API client
   - `app/api/notion/chat-tools/route.ts` - API proxy
   - `supabase/functions/chat-stream/index.ts` - Edge Function integration
   - `supabase/migrations/20260131000000_create_user_notion_api_keys.sql` - Key storage

### Current Capabilities

| Feature | Custom Integration | Notion FDW |
|---------|-------------------|------------|
| Read Data | ✅ Via API | ✅ Via SQL |
| Write Data | ✅ Via API | ❌ Not supported |
| User-Specific Keys | ✅ Encrypted storage | ❌ Global config |
| Role-Based Access | ✅ Custom logic | ❌ Not applicable |
| AI Agent Tools | ✅ MCP integration | ❌ Not applicable |
| SQL Queries | ❌ Not available | ✅ Native SQL |
| Joins with App Data | ❌ Manual | ✅ Native SQL joins |
| Real-Time Updates | ✅ API polling | ✅ On-demand queries |

---

## 5. Comparison: Custom vs FDW Approach

### Custom Integration (Current)

**Pros**:
- ✅ Full read/write capabilities
- ✅ User-specific API keys (multi-tenant)
- ✅ Custom business logic and validation
- ✅ AI agent integration via MCP
- ✅ Role-based access control
- ✅ Flexible error handling

**Cons**:
- ❌ No native SQL queries
- ❌ Cannot join with app data directly
- ❌ Requires API calls for every operation
- ❌ More complex codebase
- ❌ Manual sync logic

### Notion FDW (Alternative)

**Pros**:
- ✅ Native SQL queries
- ✅ Can join with app data
- ✅ Simpler queries for read operations
- ✅ Leverages Postgres query optimizer
- ✅ No API key management in code

**Cons**:
- ❌ Read-only (no writes)
- ❌ Global configuration (not user-specific)
- ❌ No AI agent integration
- ❌ No custom business logic
- ❌ Requires Supabase integration setup

---

## 6. Hybrid Approach Recommendation

### Best of Both Worlds

We can use **both approaches** for different use cases:

#### Use Notion FDW For:
1. **Analytics & Reporting**:
   ```sql
   -- Join Notion tasks with app data
   SELECT 
     nt.title,
     nt.status,
     u.email,
     COUNT(*) as task_count
   FROM notion_tasks nt
   JOIN profiles u ON nt.assigned_to = u.notion_user_id
   GROUP BY nt.title, nt.status, u.email;
   ```

2. **Complex Queries**:
   - Cross-database queries
   - Aggregations
   - Filtering and sorting

3. **Read-Only Operations**:
   - Dashboard displays
   - Reports
   - Data exports

#### Use Custom Integration For:
1. **Write Operations**:
   - Creating tasks
   - Updating status
   - Adding ideas

2. **User-Specific Operations**:
   - Multi-tenant scenarios
   - User-specific API keys

3. **AI Agent Integration**:
   - MCP tool calling
   - Dynamic database selection

4. **Custom Business Logic**:
   - Validation
   - Transformations
   - Role-based access

---

## 7. Implementation Plan: Incorporating Notion FDW

### Phase 1: Setup & Configuration

1. **Enable Notion Integration**:
   ```bash
   # Via Supabase Dashboard
   # Database → Integrations → Notion → Enable
   ```

2. **Create Foreign Tables**:
   ```sql
   -- Migration: Create foreign tables for common Notion databases
   CREATE FOREIGN TABLE notion_tasks (
     id TEXT,
     title TEXT,
     status TEXT,
     assigned_to TEXT,
     due_date TIMESTAMP,
     created_time TIMESTAMP,
     last_edited_time TIMESTAMP
   ) SERVER notion_server
   OPTIONS (
     database_id 'tasks-database-id'
   );

   CREATE FOREIGN TABLE notion_ideas (
     id TEXT,
     title TEXT,
     category TEXT,
     status TEXT,
     created_time TIMESTAMP
   ) SERVER notion_server
   OPTIONS (
     database_id 'ideas-database-id'
   );
   ```

### Phase 2: Create Helper Functions

```sql
-- Function to get user's tasks from Notion
CREATE OR REPLACE FUNCTION get_notion_tasks_for_user(user_id UUID)
RETURNS TABLE (
  task_id TEXT,
  title TEXT,
  status TEXT,
  due_date TIMESTAMP
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    nt.id,
    nt.title,
    nt.status,
    nt.due_date
  FROM notion_tasks nt
  JOIN profiles p ON p.id = user_id
  WHERE nt.assigned_to = p.notion_user_id
    AND nt.status != 'Done'
  ORDER BY nt.due_date ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Phase 3: Create Views for Common Queries

```sql
-- View: User's active tasks from Notion
CREATE VIEW user_notion_tasks AS
SELECT 
  p.id as user_id,
  p.email,
  nt.id as task_id,
  nt.title,
  nt.status,
  nt.due_date,
  nt.created_time
FROM notion_tasks nt
JOIN profiles p ON nt.assigned_to = p.notion_user_id
WHERE nt.status IN ('To Do', 'In Progress');

-- View: Notion tasks joined with app data
CREATE VIEW notion_tasks_with_app_data AS
SELECT 
  nt.id as notion_task_id,
  nt.title,
  nt.status,
  p.id as user_id,
  p.dynamic_role,
  COUNT(ig.id) as related_image_generations
FROM notion_tasks nt
JOIN profiles p ON nt.assigned_to = p.notion_user_id
LEFT JOIN image_generations ig ON ig.notion_page_id = nt.id
GROUP BY nt.id, nt.title, nt.status, p.id, p.dynamic_role;
```

### Phase 4: Integration Points

1. **API Routes** (Read Operations):
   ```typescript
   // app/api/notion/tasks/route.ts
   export async function GET(request: Request) {
     const { data, error } = await supabase
       .rpc('get_notion_tasks_for_user', { user_id: userId })
     
     return Response.json(data)
   }
   ```

2. **Dashboard Components**:
   ```typescript
   // Use SQL queries for analytics
   const { data: tasks } = await supabase
     .from('user_notion_tasks')
     .select('*')
     .eq('user_id', userId)
   ```

3. **Keep Custom Integration for Writes**:
   ```typescript
   // Still use API for creating/updating
   await fetch('/api/notion/chat-tools', {
     method: 'POST',
     body: JSON.stringify({
       tool: 'notion_create_task',
       // ...
     })
   })
   ```

---

## 8. Migration Strategy

### Step-by-Step Approach

1. **Week 1: Setup**
   - Enable Notion integration in Supabase
   - Create foreign tables for primary databases
   - Test queries

2. **Week 2: Helper Functions**
   - Create RPC functions for common queries
   - Create views for analytics
   - Add indexes where needed

3. **Week 3: Integration**
   - Update API routes to use FDW for reads
   - Keep custom integration for writes
   - Update dashboard components

4. **Week 4: Testing & Optimization**
   - Performance testing
   - Query optimization
   - Error handling

---

## 9. Considerations & Limitations

### Notion FDW Limitations

1. **Read-Only**: Cannot write data back to Notion
2. **Global Config**: Not user-specific (unless using multiple servers)
3. **Performance**: Queries hit Notion API (may be slower than cached data)
4. **Rate Limits**: Subject to Notion API rate limits
5. **Schema Changes**: Foreign tables need updates when Notion schema changes

### When NOT to Use FDW

- ❌ Write operations (use custom API)
- ❌ User-specific API keys (use custom integration)
- ❌ Real-time updates (use custom integration with polling)
- ❌ Complex business logic (use custom integration)

### When to Use FDW

- ✅ Analytics and reporting
- ✅ Complex SQL queries
- ✅ Joining Notion data with app data
- ✅ Read-only dashboards
- ✅ Data exports

---

## 10. Recommended Next Steps

### Immediate Actions

1. ✅ **Research**: Review Supabase Notion integration documentation
2. ✅ **Test**: Enable integration in development environment
3. ✅ **Prototype**: Create a simple foreign table and test queries
4. ✅ **Evaluate**: Compare performance with current API approach

### Short-Term (1-2 weeks)

1. Create foreign tables for primary Notion databases
2. Build helper functions for common queries
3. Create views for analytics
4. Update dashboard to use FDW for read operations

### Long-Term (1-2 months)

1. Optimize queries and add caching where needed
2. Create comprehensive analytics views
3. Document FDW usage patterns
4. Consider additional FDW integrations (Stripe, GitHub, etc.)

---

## 11. Additional Supabase Integrations Available

### Other FDWs Worth Considering

1. **Stripe FDW**: Query Stripe data directly from Postgres
2. **GitHub FDW**: Access GitHub repositories/issues via SQL
3. **Google Sheets FDW**: Query Google Sheets as tables
4. **Airtable FDW**: Access Airtable bases via SQL

### Webhook Integrations

- Slack notifications
- Discord notifications
- Email services
- Custom webhooks

---

## 12. Conclusion

### Summary

- **Current State**: Custom Notion integration with full read/write capabilities
- **FDW Available**: Notion wrapper exists but is read-only
- **Recommendation**: Use **hybrid approach**
  - FDW for analytics, reporting, and complex queries
  - Custom integration for writes, user-specific operations, and AI agents

### Key Takeaways

1. ✅ Notion FDW is available and can be enabled
2. ✅ Best used for read-only analytics and reporting
3. ✅ Keep custom integration for writes and user-specific operations
4. ✅ Hybrid approach provides best of both worlds
5. ✅ Can join Notion data with app data using native SQL

### Final Recommendation

**Implement Notion FDW alongside existing custom integration**:
- Use FDW for dashboard analytics and complex queries
- Use custom integration for writes and AI agent tools
- This provides maximum flexibility and performance

---

**Report Generated**: 2025-02-01  
**Next Review**: After FDW implementation  
**Status**: Ready for Implementation


